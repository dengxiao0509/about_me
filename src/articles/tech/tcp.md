# TCP协议介绍 

> 本文介绍了 TCP 这一面向连接、可靠的、基于字节流的运输层协议，通过对协议头、通信过程中的三次握手和四次挥手过程的详细介绍，说明了这三个特性各自的实现方式及意义。最后，还与非连接的 UDP 协议做了对比。通过阅读此文，相信您可以对TCP协议有比较全面的认识。

## 协议分层
参考模型：

    | 应用层 （如HTTP、FTP、TELNET）|
    |---------------------------------|
    | 运输层 （TCP或UDP） |
    | 网络层 （IP） |
    | 网络接口层 （如Ethernet）|


## TCP 协议

TCP （Transmission Control Protocol，传输控制协议） 是一种**面向连接的、可靠的、基于字节流**的传输协议，那么它的具体协议内容及通信机制是怎样的呢？

### 与前两层协议的关系 

##### 网络接口层
负责接收IP数据并通过网络发送，或者从网络上接收物理帧，抽出IP数据报，交给IP层。

比如以太网（Ethernet）协议，规定了电子信号如何组成数据包（package），解决了**子网内的点对点通信**。例如总线型，star型，ring型等。

##### 网络层
负责相邻计算机之间的通信。其功能包括：

1. 处理来自传输层的分组发送请求，收到请求后，将分组放入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口；
2. 处理输入的数据报：检查其合法性，然后寻径——如果已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；如果尚未到达，则转发该数据报；
3. 处理路径、流控、拥塞等问题。

比如IP协议，解决**多个局域网互通**的问题。它定义了一套自己的地址规则，称为IP地址，基于此实现路由功能。


##### 传输层
提供应用程序间的通信，比如浏览器和和网络软件。其功能包括：

1. 格式化数据流；
2. 提供可靠传输。

IP协议只是一个地址协议，并不保证数据包的完整性，而 TCP 协议的功能就是**保证通信的完整性和可靠性**。

以上三层协议关系的示例如下：
<img src="/img/articles/tcp8.png">
以太网数据包的大小是固定的（1522字节），但各种协议头都需要占用字节，所以TCP实际负载在1400字节左右。

### 基于字节流

应用层发送的数据，会在 TCP 的发送端缓存起来，统一分片或打包；到接收端端时候，也是直接按照字节流将数据传送给应用层。对比来看，UDP 就不会做这个工作，一般一个应用的数据就是一个UDP包。


#### TCP 协议头
<img src="/img/articles/tcp1.png">


##### source port & destination port

TCP 头中的 源端口 和 目标端口，分别对应发出／接收请求的应用端口。这与IP层中的IP地址对一起，标识了一个TCP连接。一个IP地址和一个端口号的组合叫做一个**endpoint**或者**socket**。也即一对endpoint或者一对socket唯一的标识了一个TCP连接。接收端的TCP层就是根据不同的端口号来将数据包传送给应用层的不同程序，这个过程叫做**解复用**(demultiplex)。相应的发送端会把应用层不同程序的数据映射到不同的端口号，这个过程叫做**复用**(multiplex)。


##### Seq Number & Ack Number
序列码（SN）和 应答码（ACK），分别用来标识当前传送的包的序列号，和期望接收的下一个包的序列号。这两个参数主要是防止丢包和包乱序，具体可参考后面的通信过程。

当 SYN 标识位有效时，序列码实际上是初始序列码（ISN，inital SN），而第一个数据的字节是 ISN + 1 byte。

##### Window Size
用来标识当前接收端还愿意接收多少bytes的数据。用于流量控制。

##### CheckSum位
CheckSum 是根据伪头+TCP头+TCP数据三部分进行计算的。送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。

##### Urgent  Pointer
优先指针（紧急,Urgent  Pointer）：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

##### 标志位
- SYN：该标志仅在三次握手建立TCP连接时有效，用于设置 ISN。当这个标志位有效时，我们称这个包为SYN包；

- ACK：取值1代表 ACK Number 字段有效，这是一个确认的TCP包。当有效时，我们称这个包为 ACK 包;

- FIN(Finish)：带有该标志置位的数据包用来结束一个TCP会话，但对应端口仍处于开放状态，准备接收后续数据。当FIN标志有效的时候我们称呼这个包为FIN包（在关闭TCP连接的时候使用）。

其他标志位，我们就不细细解读了。
 

#### TCP 数据包的组装

由于以太网协议中一个数据包只能传1400字节左右的数据，对于比较大的内容，就需要分成不同的数据包进行传输。TCP 协议会对每个数据包进行编号，通过编号确定是否有丢包问题。收到TCP数据包后，组装还原是操作系统完成的，应用程序不会直接处理 TCP 数据包。通常来说，应用程序不必关心通信的细节，它需要的数据放在 TCP 数据包里，有自己的格式（比如 HTTP 协议）。对于操作系统来说，就是持续接受 TCP 数据包，将它们按顺序组装好，一个包不少，而不关心原始文件的数据长度（这由应用层指定，比如 HTTP 的 Content-length）。

应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。

### TCP 连接
通常一次完整的TCP数据传输一般包含三个阶段，分别是连接建立(setup)、数据传输(established)和连接释放(teardown 也称为cleared 或 terminated)。

#### 连接建立 —— 三次握手
<img src="/img/articles/tcp2.png">


1. Client 主动发起连接请求，发送包中将 SYN = 1，并随机生成一个ISN，比如 x，即 序列号 seq = x。此时 Client 处于 SYN-SENT 状态；
2. 处于监听状态的 Server 在收到SYN包之后，回复一个 ACK 包，其中 SYN = 1，ACK = 1，ack = x + 1，并随机生成一个序列码，即 seq = y。虽然在建立连接的阶段，不会传送数据，但协议规范规定，SYN 包和 FIN 包在协议规定在逻辑上面占1个Byte，因此B在接收到这个SYN包后回复的 ack = x + 1。此时 B 处于 SYN-RCVD 状态；
3. A 在收到 B 的回复后，向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。此时A进入ESTABLISHED状态，A 的 TCP 通知上层应用进程，连接已经建立；
4. B 的 TCP 收到主机 A 的确认后，B也进入ESTABLISHED状态，同时通知其上层应用进程当前TCP 连接已经建立

> SYN 攻击
> 
> 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。

#### 通信过程

在建立连接之后，就可以通过TCP协议进行通信了。
<img src="/img/articles/tcp3.jpeg">

每次发送端在发送数据时，都会指定seq和数据长度length，以及期望收到的下一个数据包的序列号ack。比如第一次，A发送包的序列号为1，数据长度为100，B 在收到这个包后，会返回下一次希望获取的包序列号为101，同时发送自己的数据的序列号1和数据长度200；A收到后，回复下一次希望收到的序列号201，并发送B期望的序列号101及新的数据长度，如此循环。

#### 关闭连接 —— 四次挥手
<img src="/img/articles/tcp4.png">


1. 初始状态下A和B都是处于ESTABLISHED状态，当应用层没有待发数据而指示A关闭TCP连接的时候，A 设置连接释放报文段首部的标志位 FIN = 1，ACK=1，其序号seq = u，确认号ack=v，等待 B 的确认。此时A进入FIN_WAIT_1状态；

2. B 收到A的FIN包的时候，发出确认，由于FIN包与SYN包类似都在逻辑上占1byte，因此确认号 ack = u + 1，而这个报文段自己的序号 seq = v。此时B进入CLOSE_WAIT状态，TCP 服务器进程通知高层应用进程；

3. 当A收到B的ACK确认包后，A进入FIN_WAIT_2状态；

4. 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。B 设置连接释放报文首部的FIN=1，ACK=1，报文序列号seq=v，确认号ack=u+1。此时B进入LAST_ACK状态。；

5. A 收到连接释放报文段后，必须发出确认，在确认报文段中 ACK = 1，确认号 ack = v + 1，自己的序号 seq = u +1。 此时A进入TIME_WAIT状态。在TIME_WAIT状态下，A经过2MSL时间后就进入关闭状态。

6. 在B接收到A的确认包后，B立即进入关闭状态。A和B都进入关闭状态后整个TCP连接释放。


> 有时候会省略掉第二次的ACK包，即三次挥手。


### 可靠性保证

#### 单个数据包完整性

在数据正确性与合法性上，TCP 用一个校验和函数来检验数据是否有误、是否完整，可用md5对数据进行加密。即协议头中的Checksum字段。

#### 保证不丢包 & 正确的包顺序
采用超时重传和捎带ACK机制。

捎带 ACK 的机制，我们已经在连接的部分有所了解。每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。
<img src="/img/articles/tcp5.png">

举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。

如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。


#### 流量控制
在流量控制上，采用滑动窗口协议。
<img src="/img/articles/tcp6.png">


一个发送端的窗口如下。图中的数字表示byte也就是和上面介绍的TCP协议头中的SN是对应的，3号byte以及3号之前的数据表示已经发送并且收到了接收端的ACK确认包的数据；4、5、6三个byte表示当前可以发送的数据包，也有可能已经已经发送了但是还没有收到ACK确认包；7号byte及之后的数据表示为了控制发送速率暂时不能发送的数据。其中4-6这三个byte就称呼为窗口大小(window size)。当TCP连接建立的时候，双方会通过TCP头中的窗口大小字段向对方通告自己接收端的窗口大小，发送端依据接收端通告的窗口大小来设置发送端的发送窗口大小，另外在拥塞控制的时候也是通过调整发送端的发送窗口来调整发送速率的。

基于此，在 TCP 通信的过程中，每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。协议中规定，对于窗口内未经确认的分组需要重传。

#### 拥堵控制
为什么会产生TCP的阻塞呢，其实就是发送端发送的报文速度要接收端大，导致报文丢失，需要重传。控制阻塞的基本思想是，设立一个阻塞窗口，并且控制阻塞窗口来控制发送窗口(发送窗口=min(阻塞窗口,接收窗口))。

在拥堵控制上，采用TCP拥堵控制算法（AIMD算法）：

	- 加性增，乘性减
	- 慢启动
	- 对超时事件做出反应
	 	
拥堵又分为两种情况：

1. 重传定时器溢出了，那肯定就是有很多报文没有按时发送到接收端或者接收端的ACK报文没有到达发送端；

2. 另一种情况是没有阻塞情况没那么严重的情况，这种情况的特征是同一个报文确定了四次，这也证明了这个报文传输过程中丢失了。

TCP对于阻塞控制一共有四种算法，分别是慢启动，阻塞避免，快重传，快恢复四种算法。对于第一种情况就是重传定时器溢出的情况，TCP一般采取的措施是慢启动和拥塞避免。对于第二种情况，采用快重传快恢复算法。

##### 慢启动

服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。

TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。Linux的内核规定第一次发送10个数据包，然后动态调整。


两种算法示意图如下：
<img src="/img/articles/tcp7.jpg">


ssthresh值是一个临界点，在拥塞窗口大小小于这个值时，会指数级增长，一旦到达后，会变为加性增长。

总结来说，两种情况下，在拥塞出现的时候，都会将ssthresh值适当降低。不同之处在于，第1种超时情况下，会迅速降低拥塞窗口值，然后从慢启动开始增加；在第2种情况下，只会降低到新的ssthresh值，然后加性增加。

## 与 UDP 协议对比

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。

UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包。发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。

TCP 协议和 UDP 协议的差别：

    | | TCP  | UDP
    | -----|------------- | -------------
    | 传输可靠性  | 可靠 | 不可靠 
    | 应用场合 |   传输大量数据 | 少量数据 
    | 速度    |    慢  |        快
                



#### 参考资料

> https://blog.csdn.net/ningdaxing1994/article/details/73076795
> https://www.cnblogs.com/buxiangxin/p/8336022.html
> https://baike.baidu.com/item/TCP/33012?fr=aladdin



